(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{469:function(v,a,t){"use strict";t.r(a);var r=t(18),_=Object(r.a)({},(function(){var v=this,a=v.$createElement,t=v._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"对象的创建-内存布局和访问定位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的创建-内存布局和访问定位"}},[v._v("#")]),v._v(" 对象的创建,内存布局和访问定位")]),v._v(" "),t("p",[v._v("Java中所有一切都可以看作是对象，那对象在Java中是如何创建，如何分配内存以及如何访问的。本文以Hotspot虚拟机和Java堆为例 ，说说对象的创建，布局和访问。")]),v._v(" "),t("h3",{attrs:{id:"对象的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的创建"}},[v._v("#")]),v._v(" 对象的创建")]),v._v(" "),t("p",[v._v("Java是面向对象的语言，Java程序运行中时刻创建着对象，")]),v._v(" "),t("p",[v._v("那Java中提供了多少种创建对象的方式呢，")]),v._v(" "),t("ol",[t("li",[v._v("使用new 关键字 (调用构造函数)")]),v._v(" "),t("li",[v._v("使用Class的newInstance方法 (调用构造函数)")]),v._v(" "),t("li",[v._v("使用Constructor类的newInstance方法(调用构造函数)")]),v._v(" "),t("li",[v._v("使用clone方法(没有调用构造函数)")]),v._v(" "),t("li",[v._v("使用反序列化(没有调用构造函数)")])]),v._v(" "),t("p",[v._v("下面是对象的创建的主要流程")]),v._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-newClass.png"}}),v._v(" "),t("p",[v._v("当虚拟机遇到一条"),t("strong",[v._v("new指令")]),v._v("时，先检查常量池是否已经加载相应的类，如果没有， 必须先执行相应的类加载。类加载通过后，接下来"),t("strong",[v._v("分配内存")]),v._v("。若Java堆中内存是 绝对规整的，会使用“"),t("strong",[v._v("指针碰撞")]),v._v("“方式分配内存；如果不是规整的，就从空闲列表 中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个"),t("strong",[v._v("问题-并发")]),v._v("，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation  Buffer, TLAB)。然后内存空间"),t("strong",[v._v("初始化")]),v._v("操作，接着是做一些必要的对象设置(元信息、哈希码，GC分代年龄等)，后执行"),t("strong",[v._v("init方法")]),v._v("。")]),v._v(" "),t("h4",{attrs:{id:"对象的内存分配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存分配"}},[v._v("#")]),v._v(" 对象的内存分配")]),v._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-memory-allocation.png"}}),v._v(" "),t("p",[v._v("类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java 堆是否规整，有两种方式：")]),v._v(" "),t("p",[t("strong",[v._v("指针碰撞：")]),v._v(" 假设Java堆中的内存是绝对规整的，所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，那分配内存就是把指针向空闲空间移动一段与对象大小相等的距离，这种分配方式就是指针碰撞。")]),v._v(" "),t("p",[t("strong",[v._v("空闲列表：")]),v._v(" 如果Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，没办法使用指针碰撞，虚拟机必须维护一个列表，记录哪些内存块是可用使用的，在分配的时候找到一块足够大的空间分给对象实例，并更新列表上的记录，这种方式就是空闲列表。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("选择哪种方式是由Java堆是否规整决定的，而Java堆是否规整又由其采用的垃圾收集器是否带有压缩整理功能决定的。\n在使用Serial、ParNew 等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。\n")])])]),t("h4",{attrs:{id:"内存分配的并发安全问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配的并发安全问题"}},[v._v("#")]),v._v(" 内存分配的并发安全问题")]),v._v(" "),t("p",[v._v("对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的 位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况，解决这个问题有两种方案：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("CAS :")]),v._v("  对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的 原子性）")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("TLAB :")]),v._v("  把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆 中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,  TLAB）。jvm需要协调太多线程，不如给每个线程在堆中分配一块内存，当线程的对象需要申请内存的时候直接在自己线程的内存中分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。")])])]),v._v(" "),t("h3",{attrs:{id:"对象的内存布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存布局"}},[v._v("#")]),v._v(" 对象的内存布局")]),v._v(" "),t("p",[v._v("在hotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)，实例数据(Instance Data)，对齐填充(Padding)。其中对象头包含两部分，分别是markWord和对象指针。")]),v._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-object-layout.png"}}),v._v(" "),t("h4",{attrs:{id:"markword"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#markword"}},[v._v("#")]),v._v(" MarkWord")]),v._v(" "),t("p",[v._v("占4个字节，存储对象自身的运行时数据，也就是一系列的标记位，比如轻量级锁的标记位，偏向锁的标记位等，包含：哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。")]),v._v(" "),t("h4",{attrs:{id:"class对象指针"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class对象指针"}},[v._v("#")]),v._v(" Class对象指针")]),v._v(" "),t("p",[v._v("大小也是占4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址，虚拟机通过这个指针确定对象是哪个类的实例。"),t("strong",[v._v("但是如果对象是个数组，那么对象头中还会有一块数据用于记录数据长度")]),v._v("。")]),v._v(" "),t("h4",{attrs:{id:"实例数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例数据"}},[v._v("#")]),v._v(" 实例数据")]),v._v(" "),t("p",[v._v("这里面包括了对象的所有成员变量，包括父类继承和子类定义，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节。")]),v._v(" "),t("h4",{attrs:{id:"对齐填充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对齐填充"}},[v._v("#")]),v._v(" 对齐填充")]),v._v(" "),t("p",[v._v("不是必须的，也没有特别含义，只是起到占位符的作用。按8个字节填充。")]),v._v(" "),t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-layout-difference.png"}}),v._v(" "),t("h3",{attrs:{id:"对象怎么访问定位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象怎么访问定位"}},[v._v("#")]),v._v(" 对象怎么访问定位")]),v._v(" "),t("p",[v._v("前面我们知道对象的创建以及布局，那对象创建后是要被使用的。Java程序是通过栈上的reference数据来操作堆上的具体对象，但是reference只规定了一个指向对象的引用，但是并没有规定通过怎样的方式去访问堆中的对象，具体的访问方式是由虚拟机来实现的，目前主要是"),t("strong",[v._v("句柄")]),v._v("和"),t("strong",[v._v("直接指针")]),v._v("两种方式。")]),v._v(" "),t("h4",{attrs:{id:"句柄"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#句柄"}},[v._v("#")]),v._v(" 句柄")]),v._v(" "),t("p",[v._v("Java堆中会有一块内存最为句柄池，用来存储的对象的实例数据和类型数据的具体地址指针信息，reference中存储的就是对象的句柄地址。")]),v._v(" "),t("p",[v._v("优点：对象小，方便GC移动或者回收，而且reference中存储的是稳定的句柄地址，对象被移动只要改变句柄中的实例数据指针即可，reference本身不需要变化。")]),v._v(" "),t("p",[v._v("缺点：如下图，需要两次访问。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-handle.png",alt:"image-20211021000849925"}})]),v._v(" "),t("h4",{attrs:{id:"直接指针"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接指针"}},[v._v("#")]),v._v(" 直接指针")]),v._v(" "),t("p",[v._v("直接指针需要在Java堆中考虑如何放置访问类型数据的相关信息。")]),v._v(" "),t("p",[v._v("优点：速度快，减少一次指针定位的开销")]),v._v(" "),t("p",[v._v("缺点：GC移动对象的时候比较麻烦，需要改变reference引用。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-direct-pointer.png",alt:"image-20211021001416800"}})]),v._v(" "),t("blockquote",[t("p",[v._v("虚拟机sun HotSpot采用的是直接指针访问的对象，但是也有很多其他语言或框架使用的是句柄的方式来访问的.")])]),v._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[v._v("本文主要说了虚拟机中的对象是怎么创建的，在堆内存中的是如何布局的以及怎么访问定位到对象。")]),v._v(" "),t("ol",[t("li",[v._v("对象的创建除了创建的流程，还包括其中创建的时候内存分配的方法，有"),t("strong",[v._v("指针碰撞")]),v._v("和"),t("strong",[v._v("内存列表")]),v._v("两种方式。分配的并发安全问题的处理 "),t("strong",[v._v("CAS")]),v._v(" 和 "),t("strong",[v._v("TLAB")]),v._v("。")]),v._v(" "),t("li",[v._v("对象的内存布局分为三大块，"),t("strong",[v._v("对象头")]),v._v("(又分为"),t("strong",[v._v("markword")]),v._v("和"),t("strong",[v._v("对象指针")]),v._v(")，"),t("strong",[v._v("实例数据")]),v._v("，"),t("strong",[v._v("对齐填充")]),v._v("。 如果对象是数组的话，还要多出来一个"),t("strong",[v._v("数组长度")]),v._v("的内存块。")]),v._v(" "),t("li",[v._v("对象访问定位的两种方式，分别是"),t("strong",[v._v("直接指针")]),v._v("和"),t("strong",[v._v("句柄")]),v._v("，两者各有优缺点，都有不同的语言在使用。")])])])}),[],!1,null,null,null);a.default=_.exports}}]);