---
title: Java内存模型
date: 2022-03-14 14:33:18
permalink: /jvm/jmm/
categories:
  - Java虚拟机系列
tags:
  - 虚拟机系列
---

# Java内存模型

<img src="https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-14-JMM.png">

Java内存模型（Java Memory Model，JMM）的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。

> 这里的变量与Java中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。

Java内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中存储的是线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。

不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。线程、主内存、工作内存三者的交互关系如下图

<img src="https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-14-JMM-main-work.png">



> 上面所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区等并不是同一个层次的对内存的划分，这两者基本上是没有任何关系的。如果两者一定要勉强对应起来，那么从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分[4]，而工作内存则对应于虚拟机栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。 



### 内存交互

一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，它的实现流程并不复杂，Java内存模型中定义了以下8种操作来完成。

* **lock(锁定)**：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 

* **unlock(解锁)**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 

* **read(读取)**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 

* **load(载入)**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 

* **use(使用)**：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 

* **assign(赋值)**：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 

* **store(存储)**：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 

* **write(写入)**：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的 变量中。



如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。

<img src="https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-14-JMM-read-load.png">

**Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行**。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。



### 内存模型基本原则

Java内存模型是围绕着在并发过程中如何处理**原子性**、**可见性**和**有序性**这三个特征来建立的。

#### 原子性

原子代表不可分割的意思，原子操作不可中断。由Java内存模型来直接保证的原子性变量操作包括`read、load、assign、use、store、write`这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（long和double的非原子性是例外，可以用volatile修饰实现读写原子性）。

> volatile本身并不能解决原子性问题，能够保证修改的可见性。但是java的内存模型保证声明为volatile的long和double变量的get和set操作是原子的。

但是对于"i++"这种操作是不具有原子性的，因为涉及了读取i，计算i和写入i的三步操作，中间会被干扰导致最终结果出现差异。

如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。



#### 有序性

CPU在执行指令的时候为了保证其执行的顺畅，会对目标指令重排。重排不会导致单线程中的语义修改，但是在多线程中会出现语义不一致。即：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。

Java语言提供了`volatile`和`synchronized`两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。



#### 可见性

可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。

在Java中`synchronized`和`final`两个关键字也能实现可见性。synchronized是加锁实现的，对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。final是初始化后不可变，被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去那么在其他线程中就能可见。



### Happens-Before原则

虚拟机和执行系统会对指令进行一定的重排，但是指令重排是有原则的，并非所有的指令都可以随便改变执行位置，下面是一些基本原则，这些原则是指令重排不可违背的。

* 程序顺序原则：一个线程内保证语义的串行性。
* volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性。
* 锁规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。
* 传递性：A优先于B，B优先于C，那么A必然优先于C。
* 线程启动规则：线程的start()方法先于它的每一个动作。
* 线程终止规则：线程的所有操作都优先于此线程的终止检测(通过Thread.join()检测)。
* 线程终端规则：线程的中断(interrupt())优先于被中断线程的代码。
* 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 



### 总结

**本文介绍了主内存和工作内存之间的交互，内存模型中的原子性/可见性/有序性的基本原则，以及先行发生原则(happens-before)**。主要做个了解即可，不做底层开发以及虚拟机开发不必太在意，但是对于volatile和synchronized之类的常用关键字还是要熟悉的，避免乱用。

