---
title: 对象的创建和内存布局和访问定位
date: 2021-10-18 23:45:04
permalink: /jvm/new-class/
categories:
  - Java虚拟机系列
tags:
  - 虚拟机系列
---
# 对象的创建,内存布局和访问定位

Java中所有一切都可以看作是对象，那对象在Java中是如何创建，如何分配内存以及如何访问的。本文以Hotspot虚拟机和Java堆为例 ，说说对象的创建，布局和访问。

### 对象的创建

Java是面向对象的语言，Java程序运行中时刻创建着对象，

那Java中提供了多少种创建对象的方式呢，

1. 使用new 关键字 (调用构造函数)
2. 使用Class的newInstance方法 (调用构造函数)
3. 使用Constructor类的newInstance方法(调用构造函数)
4. 使用clone方法(没有调用构造函数)
5. 使用反序列化(没有调用构造函数)

下面是对象的创建的主要流程

<img src="https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-newClass.png">



当虚拟机遇到一条**new指令**时，先检查常量池是否已经加载相应的类，如果没有， 必须先执行相应的类加载。类加载通过后，接下来**分配内存**。若Java堆中内存是 绝对规整的，会使用“**指针碰撞**“方式分配内存；如果不是规整的，就从空闲列表 中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个**问题-并发**，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation  Buffer, TLAB)。然后内存空间**初始化**操作，接着是做一些必要的对象设置(元信息、哈希码，GC分代年龄等)，后执行**init方法**。 



#### 对象的内存分配

<img src="https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-memory-allocation.png">

类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java 堆是否规整，有两种方式：

**指针碰撞：** 假设Java堆中的内存是绝对规整的，所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，那分配内存就是把指针向空闲空间移动一段与对象大小相等的距离，这种分配方式就是指针碰撞。

**空闲列表：** 如果Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，没办法使用指针碰撞，虚拟机必须维护一个列表，记录哪些内存块是可用使用的，在分配的时候找到一块足够大的空间分给对象实例，并更新列表上的记录，这种方式就是空闲列表。

```
选择哪种方式是由Java堆是否规整决定的，而Java堆是否规整又由其采用的垃圾收集器是否带有压缩整理功能决定的。
在使用Serial、ParNew 等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。
```



#### 内存分配的并发安全问题

对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的 位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况，解决这个问题有两种方案：

* **CAS :**  对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的 原子性） 

* **TLAB :**  把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆 中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,  TLAB）。jvm需要协调太多线程，不如给每个线程在堆中分配一块内存，当线程的对象需要申请内存的时候直接在自己线程的内存中分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。



### 对象的内存布局

在hotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)，实例数据(Instance Data)，对齐填充(Padding)。其中对象头包含两部分，分别是markWord和对象指针。

<img src="https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-object-layout.png">

#### MarkWord

占4个字节，存储对象自身的运行时数据，也就是一系列的标记位，比如轻量级锁的标记位，偏向锁的标记位等，包含：哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。

#### Class对象指针

大小也是占4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址，虚拟机通过这个指针确定对象是哪个类的实例。**但是如果对象是个数组，那么对象头中还会有一块数据用于记录数据长度**。

#### 实例数据

这里面包括了对象的所有成员变量，包括父类继承和子类定义，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节。

#### 对齐填充

不是必须的，也没有特别含义，只是起到占位符的作用。按8个字节填充。

<img src="https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-layout-difference.png">



### 对象怎么访问定位

前面我们知道对象的创建以及布局，那对象创建后是要被使用的。Java程序是通过栈上的reference数据来操作堆上的具体对象，但是reference只规定了一个指向对象的引用，但是并没有规定通过怎样的方式去访问堆中的对象，具体的访问方式是由虚拟机来实现的，目前主要是**句柄**和**直接指针**两种方式。

#### 句柄

Java堆中会有一块内存最为句柄池，用来存储的对象的实例数据和类型数据的具体地址指针信息，reference中存储的就是对象的句柄地址。

优点：对象小，方便GC移动或者回收，而且reference中存储的是稳定的句柄地址，对象被移动只要改变句柄中的实例数据指针即可，reference本身不需要变化。

缺点：如下图，需要两次访问。

![image-20211021000849925](https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-handle.png)



#### 直接指针

直接指针需要在Java堆中考虑如何放置访问类型数据的相关信息。

优点：速度快，减少一次指针定位的开销

缺点：GC移动对象的时候比较麻烦，需要改变reference引用。



![image-20211021001416800](https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-4-direct-pointer.png)

> 虚拟机sun HotSpot采用的是直接指针访问的对象，但是也有很多其他语言或框架使用的是句柄的方式来访问的.



### 总结

本文主要说了虚拟机中的对象是怎么创建的，在堆内存中的是如何布局的以及怎么访问定位到对象。

1. 对象的创建除了创建的流程，还包括其中创建的时候内存分配的方法，有**指针碰撞**和**内存列表**两种方式。分配的并发安全问题的处理 **CAS** 和 **TLAB**。
2. 对象的内存布局分为三大块，**对象头**(又分为**markword**和**对象指针**)，**实例数据**，**对齐填充**。 如果对象是数组的话，还要多出来一个**数组长度**的内存块。
3. 对象访问定位的两种方式，分别是**直接指针**和**句柄**，两者各有优缺点，都有不同的语言在使用。

