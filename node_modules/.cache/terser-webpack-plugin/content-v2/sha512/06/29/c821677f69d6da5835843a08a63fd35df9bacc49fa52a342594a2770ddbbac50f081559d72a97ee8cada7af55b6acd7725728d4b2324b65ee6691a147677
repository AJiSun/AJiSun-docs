{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{467:function(v,r,a){\"use strict\";a.r(r);var t=a(18),s=Object(t.a)({},(function(){var v=this,r=v.$createElement,a=v._self._c||r;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"jvm运行时堆内存如何分代\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jvm运行时堆内存如何分代\"}},[v._v(\"#\")]),v._v(\" JVM运行时堆内存如何分代\")]),v._v(\" \"),a(\"p\",[v._v(\"对于大多数应用来说，Java堆(Java Heap)是Java虚拟机所管理的内在中最大的一块。Java堆是被所有线程共享的一块内在区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。虚拟机规范中的描述是：\"),a(\"strong\",[v._v(\"所有类的实例与数组对象都要在堆中分配\")]),v._v(\"。但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配，标量替换优化技术导致一些变化，\"),a(\"strong\",[v._v(\"所有对象并不都分配在堆上\")]),v._v(\"。\")]),v._v(\" \"),a(\"p\",[v._v(\"设置Java堆大小:       \"),a(\"strong\",[v._v(\"-Xms：设置最小堆空间\")]),v._v(\"，\"),a(\"strong\",[v._v(\"-Xmx：设置最大堆空间\")])]),v._v(\" \"),a(\"p\",[v._v(\"Java堆还可以细分为\"),a(\"strong\",[v._v(\"新生代\")]),v._v(\"和\"),a(\"strong\",[v._v(\"老年代\")]),v._v(\"，而新生代又可以细分为\"),a(\"strong\",[v._v(\"Eden区\")]),v._v(\"，\"),a(\"strong\",[v._v(\"From Survivor区\")]),v._v(\"，\"),a(\"strong\",[v._v(\"To Survivor区\")]),v._v(\"等\")]),v._v(\" \"),a(\"img\",{attrs:{src:\"https://cdn.jsdelivr.net/gh/AJiSun/CDN/jvm-img/jvm-1-head.png\"}}),v._v(\" \"),a(\"h3\",{attrs:{id:\"新生代\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#新生代\"}},[v._v(\"#\")]),v._v(\" 新生代\")]),v._v(\" \"),a(\"p\",[v._v(\"主要用来存放刚创建的对象(new)，新生代的内存空间占用堆的1/3。由于对象频繁创建，会导致新生代频繁触发MiniorGC 进行垃圾回收。\")]),v._v(\" \"),a(\"p\",[v._v(\"新生代可以分为\"),a(\"strong\",[v._v(\"Eden区(伊甸园)\")]),v._v(\"，\"),a(\"strong\",[v._v(\"From Survivor区\")]),v._v(\"，\"),a(\"strong\",[v._v(\"To Survivor区\")]),v._v(\"，三者的大小比是8:1:1，可以通过参数\"),a(\"code\",[v._v(\"-XX:SurvivorRatio=8\")]),v._v(\"设置。\")]),v._v(\" \"),a(\"ul\",[a(\"li\",[v._v(\"Eden区: Java对象出生地(并不是每个new对象都存放在这里，较大的对象可能直接到老年代)\")]),v._v(\" \"),a(\"li\",[v._v(\"From区：第一次gc，存活下来的对象所在的区，也是每次gc对象要移动的区。\")]),v._v(\" \"),a(\"li\",[v._v(\"To区：和from区作用一样，就是from区和to区两个空间不断移动存活的对象\")])]),v._v(\" \"),a(\"p\",[v._v(\"下面我们说下三个区的关联\")]),v._v(\" \"),a(\"p\",[v._v(\"大多数情况下，对象在新生代的Eden区中分配，当Eden区没用足够空间进行分配时，虚拟机将发起一次Minor GC。而经过这次Minor GC后仍然存活的对象将全部进入To区，再次GC的时候eden和To区中存活的对象又被复制进入到From区。就这样在每次Minor GC的时候存活的对象反复在From区和To区来回复制，每复制一次对象的年龄就+1，当年龄达到约定的年龄(默认15，\"),a(\"code\",[v._v(\"-XX:MaxTenuringThreshold=15\")]),v._v(\")之后就会进入老年代。\")]),v._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[v._v(\"为什么要有两个Survivor区？\\n由上面的流程知道，Survivor区是用来存活每次经历Minor GC的对象，经历15次之后到达老年代的对象就变少了。如果没有这个区，每次经历Minor GC后直接被送到老年代，老年代很快就被填满了，然后触发Major GC，而Major GC的代价远远大于Minor GC。\\n每次两个区来回复制存活对象是复制算法，这样解决了碎片化。\\n\")])])]),a(\"h3\",{attrs:{id:\"老年代\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#老年代\"}},[v._v(\"#\")]),v._v(\" 老年代\")]),v._v(\" \"),a(\"p\",[v._v(\"老年代的内存空间占用堆的2/3， 存放一些生命周期较长的对象，像新生代晋升过来的或者较大对象。如果老年代内存不足将进行Major GC（采用标记-清除算法），如果回收之后还是不足就会就会抛出OOM（Out of Memory）异常了。\")]),v._v(\" \"),a(\"h3\",{attrs:{id:\"永久代\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#永久代\"}},[v._v(\"#\")]),v._v(\" 永久代\")]),v._v(\" \"),a(\"p\",[a(\"strong\",[v._v(\"在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代\")]),v._v(\"。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。\")]),v._v(\" \"),a(\"div\",{staticClass:\"language-java extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[a(\"code\",[v._v(\"为什么\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[v._v(\"1.8\")]),v._v(\"改成元空间？\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[v._v(\"1.\")]),v._v(\" 字符串常量池存在于永久代中，在大量使用字符串的情况下，非常容易出现OOM的异常。\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[v._v(\"2.\")]),v._v(\" JVM加载的\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[v._v(\"class\")]),v._v(\"的总数，方法的大小等都很难确定，因此对永久代大小的指定难以确定。太小的永久代容易导致永久代内存溢出，太大的永久代则容易导致虚拟机内存紧张。\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[v._v(\"3.\")]),v._v(\" 永久代对GC的回收带来了不必要的复杂度，而且回收率偏低。\\n\")])])]),a(\"p\",[v._v(\"解释：\")]),v._v(\" \"),a(\"p\",[a(\"strong\",[v._v(\"新生代GC(Minor GC)\")]),v._v(\"：发生在新生代的垃圾收集动作，因为Java对象大多都具有朝生夕死的特性，所以Minor GC很频繁，一般回收速度也比较快。\")]),v._v(\" \"),a(\"p\",[a(\"strong\",[v._v(\"老年代GC(Major GC/Full GC)\")]),v._v(\"：发生在老年代的GC，出现Major GC 经常会伴有至少一次Minor GC(不是一定)，Major GC的速度一般比Minor GC慢10倍以上。\")])])}),[],!1,null,null,null);r.default=s.exports}}]);","extractedComments":[]}